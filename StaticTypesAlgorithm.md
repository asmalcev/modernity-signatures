# Алгоритм статического определения типов

В следующем примере нет никакой сложности в том, чтобы определить, что метод `from` вызывается для объекта `Array`, а значит и проверить поддержку этой возможности языка нетрудно
```js
Array.from([])
```

Babel предоставит информацию о том, что было использовано `ArrayExpression`, а значит и `map` вызывается снова для массива — тоже несложно
```js
[1, 2, 3].map(a => a + 1)
```

Другое дело в примере с обращением к методу конкретного экземпляра массива, присвоенного переменной. В таком случае придется как-то сохранить информацию о том, что `arr` содержит массив
```js
const arr = [1, 2, 3];
arr.map(a => a + 1);
```

## Скоуп переменных

- Обращение к необъявленным переменным игнорируется
  ```js
  const b = [];
  a.map(Number); // ignore dynamic type for a
  ```
- Новый уровень скоупа создается на каждое `{}` (`BlockStatemt`) (single-statement context не проблема)
  ```js
  const foo = () => { ... }
  for (let i = 0; i < 10; i++) { ... }
  while (true) { ... }
  if (true) { ... }

  const foo = () => const a = 5;            // INVALID
  for (let i = 0; i < 10; i++) const a = 5; // INVALID
  while (true) const a = 5;                 // INVALID
  if (true) const a = 5;                    // INVALID
  ```
- На любом уровне скоупа должны быть доступны все переменные со всех уровней выше
- Переменные добавляются в скоуп/изменяются в скоупе только на `VariableDeclaration` и `AssignmentExpression`
  ```js
  let a = 1;
  a = 2;
  ```

## Параметры функции

Не получится определить типы параметров функции

```ts
const mapFuncToArray = (array, mapper) => array.map(mapper);
```